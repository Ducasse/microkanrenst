
\documentclass[a4paper,12pt]{article}

\usepackage{inputenc}
\usepackage{euler}
\usepackage[T1]{fontenc}
\usepackage{libertine}
\usepackage{lipsum}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{acronym}
\usepackage{hyperref}
\usepackage{tabu}
\usepackage{rotating}
\usepackage{mathdots}
\usepackage{minted}
\usepackage{units}
\usepackage{float}
\usepackage{bbold}
\usepackage[sort&compress,square,comma,authoryear]{natbib}

\fvset{fontsize=\normalsize}
\setmonofont[Scale=0.8]{Menlo}
\usemintedstyle{xcode}
\hypersetup{colorlinks=false, citecolor=Violet}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}

\newcommand{\stcode}[1]{\mintinline[fontsize=\footnotesize]{smalltalk}{#1}}

\author{Massimo Nocentini}
\title{Relational programming in Smalltalk}

\begin{document}

\maketitle

\begin{abstract}
This booklet is an extended description of $\mu$Kanren, a relational
interpreter formerly implemented in Scheme and ported in Smalltalk for the sake
of understanding and, of course, fun. It enjoys simplicity and elegance despite
the complex nature of logic systems; moreover, using an uniform but powerful
language such as Smalltalk it is possible to appreciate and benefit from both
properties.
\end{abstract}

\section*{Introduction}

\input{introduction.tex}

\tableofcontents

\section{Preparing the wires...}

\subsection{\texttt{Goal}s and \texttt{State}s}

A \textit{goal} is any object that responds to the selector \Verb|#onState:| so
that it receives a substitution and produces an ordered sequence of zero or
more substitutions. In turn, a substitution is an unordered collection of
values which are indexed by \textit{logic variables}, therefore a
\Verb|Dictionary| object fits perfectly; we wrap it in a \Verb|State| object
that also keeps record of an incremental numbering \Verb|birthdate| whose
meaning will be clarified later when we'll describe the \Verb|Fresh|
goal\footnote{put here the reference to its subsection}. An empty substitution
is created by \stcode{Dictionary new asState} where
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Dictionary>>#asState
    ^ State new
        birthdate: 0;
        substitution: self;
        yourself
\end{minted}
and it can be augmented by
\begin{minted}[fontsize=\footnotesize]{smalltalk}
State>>#at: aVar put: aValue
    | s |
    s := substitution copy.
    s "check that if a key already exists at aVar, then the values must be the same"
      at: aVar
      ifPresent: [:v | aValue = v ifFalse: [UnificationError signal]]
      ifAbsentPut: aValue.
    ^ self class new
        birthdate: birthdate;
        substitution: s;
        yourself
\end{minted}
mantaining a protocol coherent to the one of \Verb|Dictionary| objects for
extension.

\subsection{\texttt{Chain}s and \texttt{Cons}es}

Because the sequence of substitutions may be infinite, we
represent it not as a \Verb|LinkedList| object but as a \Verb|Chain| object;
as usual, we find \Verb|BlockClosure| objects good candidates to represent (a possibly
infinite) computation. Some examples are in order,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
ChainTest>>#collatz: o
    ^ o
        cons: [o even
                ifTrue: [self collatz: o / 2]
                ifFalse: [self collatz: 3 * o + 1]]

ChainTest>>#fibs
    ^ self fib: 0 fib: 1

ChainTest>>#fib: m fib: n
    ^ m cons: [self fib: n fib: m + n]

ChainTest>>#gcd: m gcd: n
    ^ m cons: [n isZero
                ifTrue: [Chain with: m]
                ifFalse: [self gcd: n gcd: m \\ n]]

ChainTest>>#nats
    ^ self ints: 0

ChainTest>>#ints: i
    ^ i cons: [self ints: i + 1]

ChainTest>>#zeroOneTwo
    ^ 0 cons: (1 cons: (2 cons: Chain bottom))
\end{minted}
where any \Verb|Object| object respond to the message
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Object>>#cons: anObj
    ^ anObj consedObject: self
\end{minted}
which dispatches over
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Object>>#consedObject: car
    ^ Cons car: car asCons cdr: self asCons

BlockClosure>>#consedObject: car
    ^ Chain item: car linker: self

Chain>>#consedObject: car
    ^ car cons: [self]
\end{minted}
where (i)~\Verb|Cons| objects mimic \textit{Lisp's cons cells}
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Cons class>>#car: anObj cdr: anotherObj 
    ^ self new 
        car: anObj;
        cdr: anotherObj;
        yourself

Object>>#asCons
    ^ Cons fromObject: self

Cons class>>#fromObject: anObj 
    ^ anObj
\end{minted}
and (ii)~the abstract class \Verb|Chain| provides the following class-side messages
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Chain class>>#bottom
    ^ Bottom new

Chain class>>#item: anObj linker: aBlockClosure
    ^ Knot new
        item: anObj;
        linker: aBlockClosure;
        yourself

Chain class>>#with: anObj
    ^ anObj cons: Chain bottom

Chain class>>#repeat: anObj
    ^ anObj cons: [self repeat: anObj]
\end{minted}
together with its two subclasses \Verb|Knot| and \Verb|Bottom|. A comprehensive
test case follows
\begin{minted}[fontsize=\footnotesize]{smalltalk}
ChainTest>>#testNumbers
    self
        assert: Chain bottom contents
        equals: LinkedList new.
    self
        assert: (self nats next: 10) contents
        equals: (0 to: 9).
    self
        assert: (self zeroOneTwo next: 10) contents
        equals: (0 to: 2).
    self
        assert: (self zeroOneTwo next: 1) contents
        equals: (0 to: 0).
    self
        assert: (self fibs next: 10) contents
        equals: {0. 1. 1. 2. 3. 5. 8. 13. 21. 34}.
    self
        assert: ((self collatz: 10) next: 10) contents
        equals: {10. 5. 16. 8. 4. 2. 1. 4. 2. 1}.
    self
        assert: ((self gcd: 18 gcd: 32) next: 10) contents
        equals: {18. 32. 18. 14. 4. 2. 2}.
    self
        assert: ((Chain repeat: 4) next: 10) contents
        equals: {4. 4. 4. 4. 4. 4. 4. 4. 4. 4}
\end{minted}

On one hand, when a \Verb|Chain| object (i)~receives the selector
\Verb|#next:| that carries a \Verb|SmallInteger| object $i$ it keeps at most
$i$ objects and then truncate itself, precisely
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Bottom>>#next: anInteger
    ^ self

Knot>>#next: n
    ^ n isZero
        ifTrue: [Chain bottom]
        ifFalse: [[self next value next: n - 1] links: item]
\end{minted}

On the other hand, when a \Verb|Chain| object (ii)~receives the selector
\Verb|#contents| it builds a \Verb|LinkedList| object \textit{eagerly},
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Bottom>>#contents
    ^ LinkedList new

Knot>>#contents
    ^ self next contents
        addFirst: item;
        yourself
\end{minted}
where \Verb|Knot| objects provide the following simple but fundamental message
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Knot>>#next
    ^ linker value
\end{minted}
Observe that the \Verb|Chain| hierarchy support the protocol provided
by \Verb|ReadStream| objects because of the messages \Verb|#next|, \Verb|#next:|
and \Verb|#contents|.

\subsection{\texttt{Runner}s, \texttt{Reifier}s and \texttt{Var}s}

Recall that a goal $g$ responds with a \Verb|Chain| that contains either zero,
one, or more substitutions when it receives the message \Verb|#onState:|; in order
to manipulate those substitutions, $g$ provides the message
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Goal>>#solutions
    ^ Runner onGoal: self

Runner class>>#onGoal: aGoal 
    ^ self new 
        goal: aGoal;
        yourself
\end{minted}
which builds a \Verb|Runner| object able to process the sequence of substitution, both (i)~all of them with the message
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Runner>>#all
    | chain |
    chain := goal onState: self emptyState.
    ^ self reify: chain contents
\end{minted}
and (ii)~at most $n$ of them with the message
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Runner>>#atMost: anInteger 
    | chain |
    chain := goal onState: self emptyState.
    ^ self reify: (chain next: anInteger) contents
\end{minted}
using the helper message 
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Runner>>#emptyState
    ^ Dictionary new asState
\end{minted}

We are now ready to describe the reification process which starts in
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Runner>>#reify: states 
    | vars |
    vars := goal vars ifEmpty: [{Var tautology}].
    ^ states
        collect: [:s | "`s` stands for `state`"
                    | rs | "`rs` stands for `reified state`"
                    rs := s reify: vars.
                    rs size = 1 ifTrue: [rs first] ifFalse: [rs]]
\end{minted}
where the accessor \Verb|#vars| is defined for any \Verb|Goal| objects and overridden by \Verb|Fresh| goals 
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Goal>>#vars
    ^ {}

Fresh>>#vars
    ^ vars
\end{minted}
respectively; in parallel, every \Verb|State| object responds to the selector \Verb|#reify:| with
\begin{minted}[fontsize=\footnotesize]{smalltalk}
State>>#reify: vars 
    | walker reifier |
    walker := Walker on: self.
    reifier := Reifier on: Dictionary new asState.
    ^ vars
        collect: [:v | 
                    | w s |
                    w := walker walkStar: v.
                    s := reifier reify: w.
                    (Walker on: s) walkStar: w]
\end{minted}
where a \Verb|Walker| object is built by 
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Walker class>>#on: aState
    ^ self new 
        state: aState;
        yourself
\end{minted}
and it responds to the selector \Verb|#walkStar| with
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Walker>>#walkStar: aVar 
    ^ (state walk: aVar)
        walkStarUsingWalker: self
\end{minted}
which relies on 
\begin{minted}[fontsize=\footnotesize]{smalltalk}
State>>#walk: anObj 
    | k |
    k := anObj.
    [k := substitution
            at: k
            ifAbsent: [^ k]] repeat
\end{minted}
and different objects responds to \Verb|#walkStarUsingWalker:| as follows
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Object>>#walkStarUsingWalker: aWalker
    ^ aWalker walkStarObject: self 

Array>>#walkStarUsingWalker: aWalker
    ^ aWalker walkStarArray: self

LinkedList>>#walkStarUsingWalker: aWalker
    ^ aWalker walkStarLinkedList: self 

Cons>>#walkStarUsingWalker: aWalker
    ^ aWalker walkStarCons: self 
\end{minted}
dispatching over \Verb|Walker| objects
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Walker>>#walkStarObject: anObj 
    ^ state walk: anObj

Walker>>#walkStarArray: aCollection 
    ^ aCollection
        collect: [:each | self walkStar: each]

Walker>>#walkStarLinkedList: aCollection 
    ^ aCollection
        collect: [:each | self walkStar: each] 

Walker>>#walkStarCons: aCons 
    | car cdr |
    car := self walkStar: aCons car.
    cdr := self walkStar: aCons cdr.
    ^ car cons: cdr 
\end{minted}
respectively.

\section{Bootstrapping $\mu$Kanren}

We believe that an unusual development process can be done in Smalltalk and it
is the one that had driven and currently drives the present description.
Instead of creating classes first, we start by looking at some \textit{existing
object} that can be a good candidate to take into account our messages; in
sight of this approach, we give the fundamentals of $\mu$Kanren -- more
generally, for a class of logic programming languages -- starting from the two
nice boolean objects.

\subsection{\texttt{Succeed} and \texttt{Fail} classes}

Let us consider the object \Verb|false| whose responsibility is to represent
\textit{falsehood}, hence it should be a good candidate to provide us something
related to this from the \textit{relational} point of view,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
false asGoal
\end{minted}
namely, \Verb|false| can build for us an object that represents a relation that
cannot be satisfied at all responding to the message selector \Verb|asGoal| --
don't be scared by multiple names, we freely interchange the terms
\textit{goal} and \textit{relation} postponing to later sections the
description of their technical difference. Moreover, let us
assume that the infrastructure that actually builds results is given and implemented
by the block \texttt{B := [:g | g solutions all]}, we write our first test case:
\begin{minted}[fontsize=\footnotesize]{smalltalk}
GoalTest>>#testFail
    self
        assert: false asGoal solutions all
        equals: {}
\end{minted}
Now we extend the \Verb|False| class with the following \Verb|asGoal| message
definition
\begin{minted}[fontsize=\footnotesize]{smalltalk}
False>>#asGoal
    ^ Goal fail
\end{minted}
and of the message
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Goal>>#fail
    ^ Fail new
\end{minted}
such that to say that \verb|Fail| denotes the impossibility to satisfy a relation
is the same to code the message
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Fail>>#onState: aState
    ^ Chain bottom
\end{minted}
which will be used within the message \Verb|solutions| sent in the block
\Verb|B| -- a lot remains to be explained, such as the \Verb|Chain| class and
streams in particular, all in what follows.

In parallel, we reproduce for the object \Verb|true| the steps did for
the object \Verb|false|; first,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
GoalTest>>#testSucceed
    self
        assert: true asGoal solutions all
        equals: {Var tautology}
\end{minted}
second,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
True>>#asGoal
    ^ Goal succeed
\end{minted}
third,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Goal>>#succeed
    ^ Succeed new
\end{minted}
fourth,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Succeed>>#onState: aState
    ^ Chain with: aState
\end{minted}

\section{Theoretical backgrounds}

We quickly review some mathematical backgrounds underlying logic systems;
in particular deductions are performed according to \emph{resolution} methods.

\subsection{Resolution by refutation}

Let $\alpha$ be a sentence in \emph{conjunctive normal
form} (CNF for short) and $M(\alpha)$ the set of models that satisfy $\alpha$
-- recall that a \emph{model} is a set of assignments of values to free
variables in $\alpha$ that make the whole sentence true.  We say that, on one
hand, $\alpha$ is \textit{valid} if it is true in \textit{all} models; on the
other hand, $\alpha$ is \textit{satisfiable} if it is true in \textit{some}
model.

Let $\models$ and $\Rightarrow$ denote the \textit{entail} and \textit{imply}
relations, respectively; so,
\begin{displaymath}
\begin{split}
\alpha \models \beta \leftrightarrow
M(\alpha) \subseteq M(\beta) \leftrightarrow
(\alpha \Rightarrow \beta) \text{ is valid } \leftrightarrow
\neg(\neg\alpha \vee \beta) \text{ is unsatisfiable.}
\end{split}
\end{displaymath}
Therefore, to prove a sentence $\alpha$ reduces to prove
$\neg\alpha\models\perp$, where $\perp$ denotes the empty clause $()$, namely
\textit{falsehood}, which can be deduced by the \textit{resolution rule}
introduced in \citep{Robinson:1965:MLB:321250.321253}; if $l_{i}$ and $m_{r}$
bound to the same variable then
\begin{displaymath}
{\left(l_{0}, \ldots, l_{i}, \ldots, l_{j-1}\right) \quad \left(m_{0}, \ldots, m_{r},\ldots, m_{k-1}\right) \quad l_{i} = \neg m_{r}
\over
\left(l_{0},\ldots, l_{i-1},l_{i+1}, \ldots,l_{j-1}, m_{0},\ldots, m_{r-1},m_{r+1},\ldots, m_{k-1}\right)}
\end{displaymath}
where $\left(l_{0},\ldots, l_{i}, \ldots, l_{j-1}\right) = l_{0}\vee \ldots
\vee l_{i} \vee \ldots \vee l_{j-1}$, for all $l_{q}, m_{w} \in\lbrace 0,1\rbrace$.
This rule is a \textit{complete} inference algorithm, namely it enumerates
\emph{all} deductions for a given sentence, although requiring
\emph{exponential} time; for the sake of concreteness, the \textit{DPLL}
algorithm \citep{Davis:1962:MPT:368273.368557}
is a recursive, depth-first enumeration of models using the
resolution rule paired with heuristics \textit{early termination},
\textit{pure symbol} and \textit{unit clause} to speed up.

\subsection{Resolution by unification}

This method was introduced in \citep{robinson_unif} and
improved by \citep{Martelli:1982:EUA:357162.357169}; it consists of solving
\textit{equations among symbolic expressions}. A \textit{solution} is denoted
as a \textit{substitution} $\theta$, namely a mapping that assigns a symbolic
values to free variables; let $G$ be a set of equations, unification proceeds
according to the following rules:
\begin{description}
\item[delete] $G \cup \lbrace t = t \rbrace \rightarrow G$
\item[decompose] $G \cup \lbrace f(s_{0}, \ldots, s_{k}) = f(t_{0}, \ldots, t_{k})\rbrace$ entails
$$G \cup \lbrace s_{0}=t_{0},\ldots, s_{k}=t_{k} \rbrace$$
\item[conflict] if $f\neq g \vee k\neq m$ then $$G \cup \lbrace f(s_{0}, \ldots, s_{k}) = g(t_{0}, \ldots, t_{m})\rbrace \rightarrow \,\perp$$
\item[eliminate] if $x \not\in vars(t)$ and $x \in vars(G)$ then $$G \cup \lbrace x = t\rbrace \rightarrow G\lbrace x \mapsto t\rbrace \cup \left\lbrace x \triangleq t\right\rbrace $$
\item[occur check] if $x \in vars(f(s_{0},\ldots,s_{k}))$ then $$G \cup \lbrace x = f(s_{0}, \ldots, s_{k})\rbrace \rightarrow \,\perp;$$
without it, generating a $\theta$ is a
\emph{recursive enumerable} problem.
\end{description}

\begin{example}
Let $x$ and $y$ be free variables, the set
$$\lbrace cons(x,cons(x,nil)) = cons(2,y)\rbrace$$
has solution $\theta = \lbrace x \mapsto 2, y \mapsto cons(2,nil) \rbrace$;
on the contrary, the set
$$ \lbrace y = cons(2,y) \rbrace $$
has no \textit{finite} solution, nonetheless
$$\theta = \lbrace y \mapsto cons(2,cons(2,cons(2,...))) \rbrace$$
is a solution upto \textit{bisimulation}
\citep{10.1007/BFb0017309, DBLP:books/daglib/0067019}.
\end{example}
\section{Conclusions and further works}


\begin{itemize}
\item A quine generator is described in \citep{Byrd:2012:MLU:2661103.2661105}
and we aim to reproduce it.

\item using \emph{OCaml} the syntax of the language can be cleanly defined by
algebraic datatypes and the type system helps in the design of the required
operators.  While object-oriented languages make extensibility a relative
simple task, this implementation is harder unless we can make changes to basic
types, at least for what concerns the central \emph{unification} procedure.
All of this is preparatory to modify the tactics mechanism of the \emph{HOL
Light} theorem prover in order to introduce the relational paradigm in that
environment.
\end{itemize}

\bibliographystyle{plainnat}
\bibliography{biblio}
\end{document}
