
\documentclass[a4paper,12pt]{article}

\usepackage{inputenc}
\usepackage{euler}
\usepackage[T1]{fontenc}
\usepackage{libertine}
\usepackage{lipsum}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{acronym}
\usepackage{hyperref}
\usepackage{tabu}
\usepackage{rotating}
\usepackage{mathdots}
\usepackage{minted}
\usepackage{units}
\usepackage{float}
\usepackage{bbold}
\usepackage[sort&compress,square,comma,authoryear]{natbib}

\fvset{fontsize=\normalsize}
\setmonofont[Scale=0.8]{Menlo}
\usemintedstyle{xcode}
\hypersetup{colorlinks=false, citecolor=Violet}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}

\newcommand{\stcode}[1]{\mintinline[fontsize=\footnotesize]{smalltalk}{#1}}

\author{Massimo Nocentini}
\title{Relational programming in Smalltalk}

\begin{document}

\maketitle

\begin{abstract}
This booklet is an extended description of $\mu$Kanren, a relational
interpreter formerly implemented in Scheme and ported in Smalltalk for the sake
of understanding and, of course, fun. It enjoys simplicity and elegance despite
the complex nature of logic systems; moreover, using an uniform but powerful
language such as Smalltalk it is possible to appreciate and benefit from both
properties.
\end{abstract}

\section*{Introduction}

\input{introduction.tex}

\tableofcontents

\section{Preparing the wires...}

\subsection{Goals and substitutions}

A \textit{goal} is any object that responds to the selector \Verb|#onState:| so
that it receives a substitution and produces an ordered sequence of zero or
more substitutions. In turn, a substitution is an unordered collection of
values which are indexed by \textit{logic variables}, therefore a
\Verb|Dictionary| object fits perfectly; we wrap it in a \Verb|State| object
that also keeps record of an incremental numbering \Verb|birthdate| whose
meaning will be clarified later when we'll describe the \Verb|Fresh|
goal\footnote{put here the reference to its subsection}. An empty substitution
is created by \stcode{Dictionary new asState} where
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Dictionary>>#asState
    ^ State new 
        birthdate: 0;
        substitution: self;
        yourself
\end{minted}
and it can be augmented by
\begin{minted}[fontsize=\footnotesize]{smalltalk}
State>>#at: aVar put: aValue 
    | s |
    s := substitution copy.
    s "check that if a key already exists at aVar, then the values must be the same"
      at: aVar
      ifPresent: [:v | aValue = v ifFalse: [UnificationError signal]]
      ifAbsentPut: aValue.
    ^ self class new 
        birthdate: birthdate;
        substitution: s;
        yourself
\end{minted}
mantaining a protocol coherent to the one of \Verb|Dictionary| objects for
extension.

\subsection{Chains}

Because the sequence of substitutions may be infinite, we
represent it not as a \Verb|LinkedList| object but as a \Verb|Chain| object;
as usual, we find \Verb|BlockClosure| objects good candidates to represent (a possibly
infinite) computation. Some examples are in order,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
ChainTest>>#fibs
    ^ self fib: 0 fib: 1

ChainTest>>#fib: m fib: n 
    ^ [self fib: n fib: m + n] links: m

ChainTest>>#gcd: m gcd: n 
    ^ [n isZero 
            ifTrue: [Chain with: m]
            ifFalse: [self gcd: n gcd: m \\ n]] 
        links: m

ChainTest>>#nats
    ^ self ints: 0

ChainTest>>#ints: i 
    ^ [self ints: i + 1] links: i

ChainTest>>#upto2
    ^ [[[Chain bottom] links: 2] links: 1] links: 0
\end{minted}
where blocks define the message \Verb|#links:| as 
\begin{minted}[fontsize=\footnotesize]{smalltalk}
BlockClosure>>#links: anObj
    ^ Chain item: anObj linker: self
\end{minted}
exposing the abstract class \Verb|Chain| and its class-side messages
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Chain class>>#bottom
    ^ Bottom new

Chain class>>#item: anObj linker: aBlockClosure 
    ^ Knot new 
        item: anObj;
        linker: aBlockClosure;
        yourself

Chain class>>#with: anObj 
    ^ [Chain bottom] links: anObj

Chain class>>#repeat: anObj 
    ^ [self repeat: anObj] links: anObj
\end{minted}
together with its two subclasses \Verb|Knot| and \Verb|Bottom|; a comprehensive
test case follows
\begin{minted}[fontsize=\footnotesize]{smalltalk}
ChainTest>>#testNumbers
    self 
        assert: Chain bottom contents 
        equals: LinkedList new.
    self
        assert: (self nats next: 10) contents
        equals: (0 to: 9).
    self
        assert: (self upto2 next: 10) contents
        equals: (0 to: 2).
    self
        assert: (self upto2 next: 1) contents
        equals: (0 to: 0).
    self 
        assert: (self fibs next: 10) contents 
        equals: {0. 1. 1. 2. 3. 5. 8. 13. 21. 34}.
    self 
        assert: ((self collatz: 10) next: 10) contents 
        equals: {10. 5. 16. 8. 4. 2. 1. 4. 2. 1}.
    self 
        assert: ((self gcd: 18 gcd: 32) next: 10) contents 
        equals: {18. 32. 18. 14. 4. 2. 2}.
    self 
        assert: ((Chain repeat: 4) next: 10) contents 
        equals: {4. 4. 4. 4. 4. 4. 4. 4. 4. 4}
\end{minted}
On one hand, when a \Verb|Chain| object (i)~receives the selector
\Verb|#next:| that carries a \Verb|SmallInteger| object $i$ it keeps at most
$i$ objects and then truncate itself, precisely  
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Bottom>>#next: anInteger 
    ^ self

Knot>>#next: n 
    ^ n isZero
        ifTrue: [Chain bottom]
        ifFalse: [[self next value next: n - 1] links: item]
\end{minted}
On the other hand, when a \Verb|Chain| object (ii)~receives the selector
\Verb|#contents| it builds a \Verb|LinkedList| object \textit{eagerly},
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Bottom>>#contents
    ^ LinkedList new

Knot>>#contents
    ^ self next contents 
        addFirst: item;
        yourself
\end{minted}
where \Verb|Knot| objects provide the following simple but fundamental message
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Knot>>#next
    ^ linker value
\end{minted}
Observe that the \Verb|Chain| hierarchy support part of the protocol provided
by\Verb|ReadStream| objects because of the messages \Verb|#next|, \Verb|#next:|
and \Verb|#contents|.


\section{Bootstrapping $\mu$Kanren}

We believe that an unusual development process can be done in Smalltalk and it
is the one that had driven and currently drives the present description.
Instead of creating classes first, we start by looking at some \textit{existing
object} that can be a good candidate to take into account our messages; in
sight of this approach, we give the fundamentals of $\mu$Kanren -- more
generally, for a class of logic programming languages -- starting from the two
nice boolean objects. 
    
\subsection{\texttt{Succeed} and \texttt{Fail} classes}    

Let us consider the object \Verb|false| whose responsibility is to represent
\textit{falsehood}, hence it should be a good candidate to provide us something
related to this from the \textit{relational} point of view,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
false asGoal
\end{minted}
namely, \Verb|false| can build for us an object that represents a relation that
cannot be satisfied at all responding to the message selector \Verb|asGoal| --
don't be scared by multiple names, we freely interchange the terms
\textit{goal} and \textit{relation} postponing to later sections the
description of their technical difference. Moreover, let us 
assume that the infrastructure that actually builds results is given and implemented
by the block \texttt{B := [:g | g solutions all]}, we write our first test case:
\begin{minted}[fontsize=\footnotesize]{smalltalk}
GoalTest>>#testFail
    self 
        assert: false asGoal solutions all 
        equals: {}
\end{minted}
Now we extend the \Verb|False| class with the following \Verb|asGoal| message
definition
\begin{minted}[fontsize=\footnotesize]{smalltalk}
False>>#asGoal
    ^ Goal fail
\end{minted}
and of the message
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Goal>>#fail
    ^ Fail new
\end{minted}
such that to say that \verb|Fail| denotes the impossibility to satisfy a relation
is the same to code the message
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Fail>>#onState: aState 
    ^ Chain bottom
\end{minted}
which will be used within the message \Verb|solutions| sent in the block
\Verb|B| -- a lot remains to be explained, such as the \Verb|Chain| class and
streams in particular, all in what follows.

In parallel, we reproduce for the object \Verb|true| the steps did for
the object \Verb|false|; first,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
GoalTest>>#testSucceed
    self 
        assert: true asGoal solutions all 
        equals: {Var tautology}
\end{minted}
second,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
True>>#asGoal
    ^ Goal succeed
\end{minted}
third,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Goal>>#succeed
    ^ Succeed new
\end{minted}
fourth,
\begin{minted}[fontsize=\footnotesize]{smalltalk}
Succeed>>#onState: aState 
    ^ Chain with: aState
\end{minted}

\section{Theoretical backgrounds}

We quickly review some mathematical backgrounds underlying logic systems;
in particular deductions are performed according to \emph{resolution} methods.

\subsection{Resolution by refutation} 

Let $\alpha$ be a sentence in \emph{conjunctive normal
form} (CNF for short) and $M(\alpha)$ the set of models that satisfy $\alpha$
-- recall that a \emph{model} is a set of assignments of values to free
variables in $\alpha$ that make the whole sentence true.  We say that, on one
hand, $\alpha$ is \textit{valid} if it is true in \textit{all} models; on the
other hand, $\alpha$ is \textit{satisfiable} if it is true in \textit{some}
model.

Let $\models$ and $\Rightarrow$ denote the \textit{entail} and \textit{imply}
relations, respectively; so,
\begin{displaymath}
\begin{split}
\alpha \models \beta \leftrightarrow
M(\alpha) \subseteq M(\beta) \leftrightarrow
(\alpha \Rightarrow \beta) \text{ is valid } \leftrightarrow
\neg(\neg\alpha \vee \beta) \text{ is unsatisfiable.}
\end{split}
\end{displaymath}
Therefore, to prove a sentence $\alpha$ reduces to prove
$\neg\alpha\models\perp$, where $\perp$ denotes the empty clause $()$, namely
\textit{falsehood}, which can be deduced by the \textit{resolution rule}
introduced in \citep{Robinson:1965:MLB:321250.321253}; if $l_{i}$ and $m_{r}$
bound to the same variable then
\begin{displaymath}
{\left(l_{0}, \ldots, l_{i}, \ldots, l_{j-1}\right) \quad \left(m_{0}, \ldots, m_{r},\ldots, m_{k-1}\right) \quad l_{i} = \neg m_{r}
\over
\left(l_{0},\ldots, l_{i-1},l_{i+1}, \ldots,l_{j-1}, m_{0},\ldots, m_{r-1},m_{r+1},\ldots, m_{k-1}\right)}
\end{displaymath}
where $\left(l_{0},\ldots, l_{i}, \ldots, l_{j-1}\right) = l_{0}\vee \ldots
\vee l_{i} \vee \ldots \vee l_{j-1}$, for all $l_{q}, m_{w} \in\lbrace 0,1\rbrace$.
This rule is a \textit{complete} inference algorithm, namely it enumerates
\emph{all} deductions for a given sentence, although requiring
\emph{exponential} time; for the sake of concreteness, the \textit{DPLL}
algorithm \citep{Davis:1962:MPT:368273.368557}
is a recursive, depth-first enumeration of models using the
resolution rule paired with heuristics \textit{early termination},
\textit{pure symbol} and \textit{unit clause} to speed up.

\subsection{Resolution by unification} 

This method was introduced in \citep{robinson_unif} and
improved by \citep{Martelli:1982:EUA:357162.357169}; it consists of solving
\textit{equations among symbolic expressions}. A \textit{solution} is denoted
as a \textit{substitution} $\theta$, namely a mapping that assigns a symbolic
values to free variables; let $G$ be a set of equations, unification proceeds
according to the following rules:
\begin{description}
\item[delete] $G \cup \lbrace t = t \rbrace \rightarrow G$
\item[decompose] $G \cup \lbrace f(s_{0}, \ldots, s_{k}) = f(t_{0}, \ldots, t_{k})\rbrace$ entails
$$G \cup \lbrace s_{0}=t_{0},\ldots, s_{k}=t_{k} \rbrace$$
\item[conflict] if $f\neq g \vee k\neq m$ then $$G \cup \lbrace f(s_{0}, \ldots, s_{k}) = g(t_{0}, \ldots, t_{m})\rbrace \rightarrow \,\perp$$
\item[eliminate] if $x \not\in vars(t)$ and $x \in vars(G)$ then $$G \cup \lbrace x = t\rbrace \rightarrow G\lbrace x \mapsto t\rbrace \cup \left\lbrace x \triangleq t\right\rbrace $$
\item[occur check] if $x \in vars(f(s_{0},\ldots,s_{k}))$ then $$G \cup \lbrace x = f(s_{0}, \ldots, s_{k})\rbrace \rightarrow \,\perp;$$
without it, generating a $\theta$ is a
\emph{recursive enumerable} problem.
\end{description}

\begin{example}
Let $x$ and $y$ be free variables, the set
$$\lbrace cons(x,cons(x,nil)) = cons(2,y)\rbrace$$
has solution $\theta = \lbrace x \mapsto 2, y \mapsto cons(2,nil) \rbrace$;
on the contrary, the set
$$ \lbrace y = cons(2,y) \rbrace $$
has no \textit{finite} solution, nonetheless
$$\theta = \lbrace y \mapsto cons(2,cons(2,cons(2,...))) \rbrace$$
is a solution upto \textit{bisimulation}
\citep{10.1007/BFb0017309, DBLP:books/daglib/0067019}.
\end{example}
\section{Conclusions and further works}


\begin{itemize}
\item A quine generator is described in \citep{Byrd:2012:MLU:2661103.2661105}
and we aim to reproduce it.

\item using \emph{OCaml} the syntax of the language can be cleanly defined by
algebraic datatypes and the type system helps in the design of the required
operators.  While object-oriented languages make extensibility a relative
simple task, this implementation is harder unless we can make changes to basic
types, at least for what concerns the central \emph{unification} procedure.
All of this is preparatory to modify the tactics mechanism of the \emph{HOL
Light} theorem prover in order to introduce the relational paradigm in that
environment.
\end{itemize}

\bibliographystyle{plainnat}
\bibliography{biblio}
\end{document}
